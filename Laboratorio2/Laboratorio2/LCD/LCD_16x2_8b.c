/*
 * LCD_16x2_8b.c
 *
 * Created: 29/01/2025 23:05:46
 *  Author: jaidy
 */ 

#include "LCD_16x2_8b.h"

// DEFINICIÓN DE PINES DE CONTROL DEL LCD
#define RS PD2   // REGISTRO DE SELECCIÓN (RS) EN EL PIN PD2
#define RW PD3   // LECTURA/ESCRITURA (RW) EN EL PIN PD3
#define E  PB4   // HABILITACIÓN (E) EN EL PIN PB4

// DEFINICIÓN DE PUERTOS PARA LOS DATOS DEL LCD
#define LCD_PORT PORTD   // PUERTO DE DATOS DEL LCD
#define LCD_DDR DDRD     // CONFIGURACIÓN COMO ENTRADA/SALIDA
#define LCD_PORTB PORTB  // PUERTO AUXILIAR PARA DATOS
#define LCD_DDRB DDRB    // CONFIGURACIÓN COMO ENTRADA/SALIDA

// FUNCIÓN PARA ENVIAR COMANDOS AL LCD
void lcd_command(unsigned char cmd) {
	LCD_PORT &= ~(1 << RS); // RS = 0, INDICA QUE ES UN COMANDO
	LCD_PORT &= ~(1 << RW); // RW = 0, INDICA QUE ES UNA ESCRITURA
	
	LCD_PORTB = (cmd & 0x0F); // ENVÍA LOS 4 BITS MENOS SIGNIFICATIVOS A PORTB
	LCD_PORT = (LCD_PORT & 0x0F) | (cmd & 0xF0); // ENVÍA LOS 4 BITS MÁS SIGNIFICATIVOS A PORTD
	
	LCD_PORTB |= (1 << E);  // PULSO DE HABILITACIÓN (E) EN ALTO
	_delay_us(1);           // PEQUEÑA ESPERA PARA QUE EL LCD REGISTRE LA ORDEN
	LCD_PORTB &= ~(1 << E); // PULSO DE HABILITACIÓN (E) EN BAJO
	_delay_ms(2);           // ESPERA PARA QUE EL LCD PROCEDA
}

// FUNCIÓN PARA INICIALIZAR EL LCD
void lcd_init(void) {
	LCD_DDR = 0xFF;  // CONFIGURA EL PUERTO D COMO SALIDA
	LCD_DDRB = 0x1F; // CONFIGURA PB0-PB3 COMO SALIDA

	_delay_ms(15); // PASO 1: ESPERAR MÁS DE 15ms TRAS ENCENDER EL LCD
	lcd_command(0x30); // PASO 2: ENVIAR COMANDO DE INICIALIZACIÓN (8 BITS)
	_delay_ms(5); // PASO 3: ESPERAR MÁS DE 4.1ms
	lcd_command(0x30); // PASO 4: REPETIR COMANDO DE INICIALIZACIÓN
	_delay_us(100); // PASO 5: ESPERAR MÁS DE 100µs
	lcd_command(0x30); // PASO 6: REPETIR COMANDO UNA VEZ MÁS

	lcd_command(0x38); // PASO 7: CONFIGURAR EN MODO DE 8 BITS, 2 LÍNEAS, MATRIZ DE CARACTERES 5x8
	lcd_command(0x08); // PASO 8: APAGAR LA PANTALLA
	lcd_command(0x01); // PASO 9: BORRAR LA PANTALLA
	_delay_ms(2); // ESPERA PARA QUE EL LCD PROCEDA
	lcd_command(0x06); // PASO 10: CONFIGURAR MODO DE INTRODUCCIÓN (INCREMENTO, SIN DESPLAZAMIENTO)
	lcd_command(0x0C); // PASO 11: ENCENDER PANTALLA Y OCULTAR CURSOR
}

// FUNCIÓN PARA ENVIAR DATOS AL LCD (IMPRIMIR CARACTERES)
void lcd_data(unsigned char data) {
	LCD_PORT |= (1 << RS);  // RS = 1, INDICA QUE ES UN DATO (NO COMANDO)
	LCD_PORT &= ~(1 << RW); // RW = 0, INDICA QUE ES UNA ESCRITURA
	
	LCD_PORTB = (data & 0x0F); // ENVÍA LOS 4 BITS MENOS SIGNIFICATIVOS A PORTB
	LCD_PORT = (LCD_PORT & 0x0F) | (data & 0xF0); // ENVÍA LOS 4 BITS MÁS SIGNIFICATIVOS A PORTD
	
	LCD_PORTB |= (1 << E);  // PULSO DE HABILITACIÓN (E) EN ALTO
	_delay_us(1);           // PEQUEÑA ESPERA
	LCD_PORTB &= ~(1 << E); // PULSO DE HABILITACIÓN (E) EN BAJO
	_delay_ms(2);           // ESPERA PARA QUE EL LCD PROCESE EL DATO
}

// FUNCIÓN PARA IMPRIMIR UNA CADENA EN EL LCD
void lcd_print(char *str) {
	while (*str) {       // ITERA SOBRE LA CADENA HASTA LLEGAR AL CARÁCTER NULO '\0'
		lcd_data(*str); // ENVÍA CADA CARÁCTER AL LCD
		str++;          // AVANZA AL SIGUIENTE CARÁCTER
	}
}

// FUNCIÓN PARA BORRAR LA PANTALLA DEL LCD
void lcd_clear(void) {
	lcd_command(0x01); // PASO 9: BORRAR PANTALLA
	_delay_ms(2);      // ESPERA A QUE EL LCD PROCEDA
}

// FUNCIÓN PARA POSICIONAR EL CURSOR EN UNA COORDENADA ESPECÍFICA (FILA Y COLUMNA)
void lcd_set_cursor(uint8_t row, uint8_t col) {
	uint8_t pos = (row == 0) ? (0x80 + col) : (0xC0 + col); // 0x80 PARA LA PRIMERA FILA, 0xC0 PARA LA SEGUNDA
	lcd_command(pos); // ENVIAR COMANDO PARA MOVER EL CURSOR
}